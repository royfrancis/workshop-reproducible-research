<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Working with Nextflow</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../assets/favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>html{ scroll-behavior: smooth; }</style>
<style>

      .quarto-title-block .quarto-title-banner {
        background-image: url(../assets/images/banner.webp);
background-size: cover;
      }
</style>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Fira+Mono&amp;family=Nunito:ital,wght@0,400;0,500;0,600;1,400;1,500;1,600&amp;display=swap" rel="stylesheet">


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../assets/logos/nbis-scilifelab.png" alt="logo" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../home_schedule.html"> 
<span class="menu-text">Schedule</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../home_contents.html"> 
<span class="menu-text">Contents</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../home_syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../home_precourse.html"> 
<span class="menu-text">Pre-course</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../home_info.html"> 
<span class="menu-text">Info</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/NBISweden/workshop-reproducible-research/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Working with Nextflow</h1>
            <p class="subtitle lead">How to create reproducible workflows and computational pipelines</p>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">18-Oct-2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#the-basics" id="toc-the-basics" class="nav-link" data-scroll-target="#the-basics"><span class="header-section-number">2</span> The basics</a>
  <ul>
  <li><a href="#workflow-definitions" id="toc-workflow-definitions" class="nav-link" data-scroll-target="#workflow-definitions"><span class="header-section-number">2.1</span> Workflow definitions</a></li>
  <li><a href="#process-definitions" id="toc-process-definitions" class="nav-link" data-scroll-target="#process-definitions"><span class="header-section-number">2.2</span> Process definitions</a></li>
  <li><a href="#executing-workflows" id="toc-executing-workflows" class="nav-link" data-scroll-target="#executing-workflows"><span class="header-section-number">2.3</span> Executing workflows</a></li>
  <li><a href="#viewing-channel-contents" id="toc-viewing-channel-contents" class="nav-link" data-scroll-target="#viewing-channel-contents"><span class="header-section-number">2.4</span> Viewing channel contents</a></li>
  <li><a href="#files-and-sample-names" id="toc-files-and-sample-names" class="nav-link" data-scroll-target="#files-and-sample-names"><span class="header-section-number">2.5</span> Files and sample names</a></li>
  <li><a href="#input-from-samplesheets" id="toc-input-from-samplesheets" class="nav-link" data-scroll-target="#input-from-samplesheets"><span class="header-section-number">2.6</span> Input from samplesheets</a></li>
  <li><a href="#adding-more-processes" id="toc-adding-more-processes" class="nav-link" data-scroll-target="#adding-more-processes"><span class="header-section-number">2.7</span> Adding more processes</a></li>
  </ul></li>
  <li><a href="#executing-workflows-1" id="toc-executing-workflows-1" class="nav-link" data-scroll-target="#executing-workflows-1"><span class="header-section-number">3</span> Executing workflows</a>
  <ul>
  <li><a href="#reports-and-visualisations" id="toc-reports-and-visualisations" class="nav-link" data-scroll-target="#reports-and-visualisations"><span class="header-section-number">3.1</span> Reports and visualisations</a></li>
  <li><a href="#logs" id="toc-logs" class="nav-link" data-scroll-target="#logs"><span class="header-section-number">3.2</span> Logs</a></li>
  <li><a href="#re-running-workflows" id="toc-re-running-workflows" class="nav-link" data-scroll-target="#re-running-workflows"><span class="header-section-number">3.3</span> Re-running workflows</a></li>
  </ul></li>
  <li><a href="#working-with-processes" id="toc-working-with-processes" class="nav-link" data-scroll-target="#working-with-processes"><span class="header-section-number">4</span> Working with processes</a>
  <ul>
  <li><a href="#tags" id="toc-tags" class="nav-link" data-scroll-target="#tags"><span class="header-section-number">4.1</span> Tags</a></li>
  <li><a href="#named-outputs" id="toc-named-outputs" class="nav-link" data-scroll-target="#named-outputs"><span class="header-section-number">4.2</span> Named outputs</a></li>
  <li><a href="#advanced-publishing" id="toc-advanced-publishing" class="nav-link" data-scroll-target="#advanced-publishing"><span class="header-section-number">4.3</span> Advanced publishing</a></li>
  <li><a href="#debugging" id="toc-debugging" class="nav-link" data-scroll-target="#debugging"><span class="header-section-number">4.4</span> Debugging</a></li>
  </ul></li>
  <li><a href="#workflow-configuration" id="toc-workflow-configuration" class="nav-link" data-scroll-target="#workflow-configuration"><span class="header-section-number">5</span> Workflow configuration</a>
  <ul>
  <li><a href="#parameters" id="toc-parameters" class="nav-link" data-scroll-target="#parameters"><span class="header-section-number">5.1</span> Parameters</a></li>
  <li><a href="#command-line-parameters" id="toc-command-line-parameters" class="nav-link" data-scroll-target="#command-line-parameters"><span class="header-section-number">5.2</span> Command line parameters</a></li>
  <li><a href="#configuring-inputs" id="toc-configuring-inputs" class="nav-link" data-scroll-target="#configuring-inputs"><span class="header-section-number">5.3</span> Configuring inputs</a></li>
  <li><a href="#other-configuration-scopes" id="toc-other-configuration-scopes" class="nav-link" data-scroll-target="#other-configuration-scopes"><span class="header-section-number">5.4</span> Other configuration scopes</a></li>
  </ul></li>
  <li><a href="#optimising-the-mrsa-workflow" id="toc-optimising-the-mrsa-workflow" class="nav-link" data-scroll-target="#optimising-the-mrsa-workflow"><span class="header-section-number">6</span> Optimising the MRSA workflow</a>
  <ul>
  <li><a href="#remote-files" id="toc-remote-files" class="nav-link" data-scroll-target="#remote-files"><span class="header-section-number">6.1</span> Remote files</a></li>
  <li><a href="#subworkflows" id="toc-subworkflows" class="nav-link" data-scroll-target="#subworkflows"><span class="header-section-number">6.2</span> Subworkflows</a></li>
  </ul></li>
  <li><a href="#extra-material" id="toc-extra-material" class="nav-link" data-scroll-target="#extra-material"><span class="header-section-number">7</span> Extra material</a>
  <ul>
  <li><a href="#using-containers-in-nextflow" id="toc-using-containers-in-nextflow" class="nav-link" data-scroll-target="#using-containers-in-nextflow"><span class="header-section-number">7.1</span> Using containers in Nextflow</a></li>
  <li><a href="#using-conda-in-nextflow" id="toc-using-conda-in-nextflow" class="nav-link" data-scroll-target="#using-conda-in-nextflow"><span class="header-section-number">7.2</span> Using Conda in Nextflow</a></li>
  <li><a href="#running-nextflow-on-uppmax" id="toc-running-nextflow-on-uppmax" class="nav-link" data-scroll-target="#running-nextflow-on-uppmax"><span class="header-section-number">7.3</span> Running Nextflow on Uppmax</a></li>
  <li><a href="#advanced-channel-creation" id="toc-advanced-channel-creation" class="nav-link" data-scroll-target="#advanced-channel-creation"><span class="header-section-number">7.4</span> Advanced channel creation</a></li>
  <li><a href="#using-groovy-in-processes" id="toc-using-groovy-in-processes" class="nav-link" data-scroll-target="#using-groovy-in-processes"><span class="header-section-number">7.5</span> Using Groovy in processes</a></li>
  <li><a href="#the-nf-core-pipeline-collection" id="toc-the-nf-core-pipeline-collection" class="nav-link" data-scroll-target="#the-nf-core-pipeline-collection"><span class="header-section-number">7.6</span> The nf-core pipeline collection</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">






<section id="introduction" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">1</span> Introduction</h2>
<p><a href="https://www.nextflow.io/">Nextflow</a> is a <em>workflow management system</em> (WfMS), and is one of the most common such systems within the bioinformatic and academic communities. These systems are important for scientific reproducibility in that they greatly facilitate keeping track of which files have been processed in what way throughout an entire project.</p>
<p>Nextflow is built from the ground-up to be portable, scalable, reproducible and usable in a platform-agnostic sense. This means that any workflow you write in Nextflow can be run locally on your laptop, a computer cluster or a cloud service (as long as your architecture has the necessary computational resources). You can also define the compute environment in which each task is carried out on a per-task basis. You might thus develop your workflow on your local computer using a minimal test dataset, but run the full analyses with all samples on <em>e.g.</em> a computer cluster. Nextflow can work on both files and arbitrary values, often-times connected in useful and advanced ways.</p>
<p>Nextflow can easily work with dynamic inputs where the exact output is unknown, <em>e.g.</em> the exact number of files or which samples pass some arbitrary quality control threshold. While Nextflow is based on the Groovy language, you don’t need to know how to code Groovy to be able to write good Nextflow workflows. Nextflow has a large community centred around it, including the <a href="https://nf-co.re/">nf-core</a> curated collection of high quality pipelines used by <em>e.g.</em> the <a href="https://ngisweden.scilifelab.se/">National Genomics Infrastructure</a>.</p>
<p>This tutorial depends on files from the course GitHub repo. Take a look at the <a href="pre-course-setup">setup</a> for instructions on how to set it up if you haven’t done so already, then open up a terminal and go to <code>workshop-reproducible-research/tutorials/nextflow</code> and activate your <code>nextflow-env</code> Conda environment.</p>
</section>
<section id="the-basics" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="the-basics"><span class="header-section-number">2</span> The basics</h2>
<p>We’ll start by creating a very simple workflow from scratch, to show how Nextflow works: it will take two input files and convert them to UPPERCASE letters.</p>
<ul>
<li>Start by running the following commands:</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">touch</span> main.nf</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"This is a.txt"</span> <span class="op">&gt;</span> a.txt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">"This is b.txt"</span> <span class="op">&gt;</span> b.txt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Open the <code>main.nf</code> file with an editor of your choice. This is the main workflow file used in Nextflow, where workflows and their processes are defined.</p>
<ul>
<li>Copy the following code into your <code>main.nf</code> file:</li>
</ul>
<pre class="nextflow"><code>// Workflow definition
workflow {
    // Define input files
    ch_input = Channel.fromPath( "a.txt" )

    // Run workflow
    CONVERT_TO_UPPER_CASE( ch_input )
}

// Process definition
process CONVERT_TO_UPPER_CASE {
    publishDir "results/",
        mode: "copy"

    input:
    path(file)

    output:
    path("a.upper.txt")

    script:
    """
    tr [a-z] [A-Z] &lt; ${file} &gt; a.upper.txt
    """
}</code></pre>
<p>Here we have two separate parts. The first is the <em>workflow definition</em>, while the last is a <em>process</em>. Let’s go through them both in more detail!</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Nextflow comments">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nextflow comments
</div>
</div>
<div class="callout-body-container callout-body">
<p>Double-slashes (<code>//</code>) are used for comments in Nextflow.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Nextflow and whitespace">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nextflow and whitespace
</div>
</div>
<div class="callout-body-container callout-body">
<p>Nextflow is not indentation-sensitive. In fact, Nextflow doesn’t care at all about whitespace, so go ahead and use it in whatever manner you think is easiest to read and work with! Do keep in mind that indentations and other types of whitespace <em>does</em> improve readability, so it’s generally not a good idea to forego it entirely, even though you can.</p>
</div>
</div>
<section id="workflow-definitions" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="workflow-definitions"><span class="header-section-number">2.1</span> Workflow definitions</h3>
<pre class="nextflow"><code>workflow {
    // Define input files
    ch_input = Channel.fromPath( "a.txt" )

    // Run workflow
    CONVERT_TO_UPPER_CASE( ch_input )
}</code></pre>
<p>The workflow definition here has two parts, each doing an important job for any Nextflow workflow. The first part defines a <em>channel</em>, which is an asynchronous first-in-first-out stream of data that connect a workflow’s various inputs and outputs. In simpler terms, channels contain the data that you want to process with the workflow and can be passed between the various parts of the workflow.</p>
<p>Channels can be created in various different ways using <em>channel factories</em>, depending on what type data you want to put into them and where this data is stored. In this particular case we define our <code>ch_input</code> channel using the <code>.fromPath</code> channel factory, which takes a file path as input - here we use the <code>a.txt</code> file. You can thus read <code>ch_input = Channel.fromPath("a.txt")</code> as <em>“create the channel <code>ch_input</code> and send the file <code>a.txt</code> into it”</em>.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Naming channels">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Naming channels
</div>
</div>
<div class="callout-body-container callout-body">
<p>A channel can be named anything you like, but it is good practice to prepend them with <code>ch_</code>, as that makes it clear which variables are channels and which are just normal variables.</p>
</div>
</div>
<p>How do we use these channels then? Channels pass data to and from processes through our workflow. By providing channels as arguments to processes, we describe how we want data to flow. This is exactly what we do in the second part: we call our <code>CONVERT_TO_UPPER_CASE</code> process with the <code>ch_input</code> as input argument - this is very similar to functional programming.</p>
<p>This is our entire workflow, for now: the creation of a channel followed by using the contents of that channel as input to a single process. Let’s look at how processes themselves are defined!</p>
</section>
<section id="process-definitions" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="process-definitions"><span class="header-section-number">2.2</span> Process definitions</h3>
<pre class="nextflow"><code>process CONVERT_TO_UPPER_CASE {
    publishDir "results/",
        mode: "copy"

    input:
    path(file)

    output:
    path("a.upper.txt")

    script:
    """
    tr [a-z] [A-Z] &lt; ${file} &gt; a.upper.txt
    """
}</code></pre>
<p>Looking at the process in the code above, we can see several parts. The process block starts with its name, in this case <code>CONVERT_TO_UPPER_CASE</code>, followed by several sections, or <em>directives</em> as Nextflow calls them: <code>publishDir</code>, <code>input</code>, <code>output</code> and <code>script</code>.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Naming processes">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Naming processes
</div>
</div>
<div class="callout-body-container callout-body">
<p>A process can be named using any case, but a commonly used convention is to use UPPERCASE letters for processes to visually distinguish them in the workflow. You do not have to follow this if you don’t want to, but we do so here.</p>
</div>
</div>
<p>Let’s start with the first directive: <code>publishDir</code>. This tells Nextflow where the output of the process should be placed when it is finished. Setting <code>mode</code> to <code>"copy"</code> just means that we want to copy the output files to the publishing directory, rather than using a symbolic link (which is the default).</p>
<p>The <code>input</code> and <code>output</code> directives describe the data expected to come through this specific process. Each line of <code>input</code> describes the data expected for each process argument, in the order used in the workflow. In this case, <code>CONVERT_TO_UPPER_CASE</code> expects a single channel (one line of input), and expects the data to be filenames ( <em>i.e.</em> of type <code>path</code>). The <code>script</code> directive is where you put the code that the process should execute.</p>
<p>Notice that there is a difference between how the inputs and outputs are declared? The <code>output</code> is an explicit string (<em>i.e.</em> surrounded by quotes), while the input is a variable named <code>file</code>. This means inputs can be referenced in the process without naming the data explicitly, unlike the output where the name needs to be explicit. We’ll get back to exactly how this works in just a moment. While the name of the input variable here is chosen to be the descriptive <code>file</code>, we could also have chosen something completely different, <em>e.g.</em> <code>banana</code> (we’d also have to change its reference in the <code>script</code> directive).</p>
</section>
<section id="executing-workflows" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="executing-workflows"><span class="header-section-number">2.3</span> Executing workflows</h3>
<p>Let’s try running the workflow we just created!</p>
<ul>
<li>Type the following in your terminal:</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">nextflow</span> run main.nf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This will make Nextflow run the workflow specified in your <code>main.nf</code> file. You should see something along these lines:</p>
<pre class="no-highlight"><code>N E X T F L O W  ~  version 22.10.6
Launching `./main.nf` [mad_legentil] - revision: 87f0c253ed
executor &gt;  local (1)
[32/9124a1] process &gt; CONVERT_TO_UPPER_CASE (1) [100%] 1 of 1 ✔</code></pre>
<p>The first few lines are information about this particular run, including the Nextflow version used, which workflow definition file was used, a randomly generated run name (an adjective and a scientist), the revision ID as well as where the processes were executed (locally, in this case, as opposed to <em>e.g.</em> SLURM or AWS).</p>
<p>What follows next is a list of all the various processes for this particular workflow. The order does not necessarily reflect the order of execution (depending on each process’ input and output dependencies), but they are in the order they were defined in the workflow file - there’s only the one process here, of course. The first part (<em>e.g.</em> <code>[32/9124a1]</code>) is the process ID, which is also the first part of the subdirectory in which the process is run (the full subdirectory will be something like <code>32/9124a1dj56n2346236245i2343</code>, so just a longer hash). We then get the process and its name. Lastly, we get how many instances of each process are currently running or have finished. Here we only have the one process, of course, but this will soon change.</p>
<ul>
<li><p>Let’s check that everything worked: type <code>ls results/</code> and see that it contains the output we expected.</p></li>
<li><p>Let’s explore the working directory: change into whatever directory is specified by the process ID (your equivalent to <code>work/32/9124a1[...]</code>).</p></li>
</ul>
<p>What do you see when you list the contents of this directory? You should see a symbolic link named <code>a.txt</code> pointing to the real location of this file, plus a normal file <code>a.upper.txt</code>, which is the output of the process that was run in this directory. You generally only move into these work directories when debugging errors in your workflow, and Nextflow has some tricks to make this process a lot easier - more on this later.</p>
<p>So, in summary: we have three components: a set of inputs stored in a channel, a set of processes and a workflow that defines which processes should be run in what order. We tell Nextflow to <em>push</em> the inputs through the entire workflow, so to speak.</p>
<ul>
<li><p>Now it’s your turn! Move back to the workflow root and make it use only the <code>b.txt</code> input file and give you the <code>b.upper.txt</code> instead.</p></li>
<li><p>Run your workflow and make sure it works before you move on; check below if you’re having trouble.</p></li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>ch_input = Channel.fromPath( "b.txt" )</code></pre>
</div>
</div>
</div>
</section>
<section id="viewing-channel-contents" class="level3" data-number="2.4">
<h3 data-number="2.4" class="anchored" data-anchor-id="viewing-channel-contents"><span class="header-section-number">2.4</span> Viewing channel contents</h3>
<p>Something that’s highly useful during development of Nextflow workflows is to view the contents of channels, which can be done with the <code>view()</code> operator.</p>
<ul>
<li><p>Add the following to your workflow definition (on a new line) and execute the workflow: <code>ch_input.view()</code>. What do you see?</p></li>
<li><p>Remove the <code>view()</code> operator once you’re done.</p></li>
</ul>
<p>It can be quite helpful to view the channel contents whenever you’re unsure of what a channel contains or if you’ve run into some kind of bug or error, or even just when you’re adding something new to your workflow. Remember to view the channel contents whenever you need to during the rest of this tutorial!</p>
</section>
<section id="files-and-sample-names" class="level3" data-number="2.5">
<h3 data-number="2.5" class="anchored" data-anchor-id="files-and-sample-names"><span class="header-section-number">2.5</span> Files and sample names</h3>
<p>One powerful feature of Nextflow is that it can handle complex data structures as input, and not only filenames. One of the more useful things this allows us to do is to couple sample names with their respective data files inside channels.</p>
<ul>
<li>Change the channel definition to the following:</li>
</ul>
<pre class="nextflow"><code>ch_input = Channel
    .fromPath ( "a.txt" )
    .map      { file -&gt; tuple(file.getBaseName(), file) }</code></pre>
<p>Here we create a <em>tuple</em> (something containing multiple parts) using the <code>map</code> operator, the <em>base name</em> of the file (<code>a</code>) and the file path (<code>a.txt</code>). The statement <code>.map{ file -&gt; tuple(file.getBaseName(), file) }</code> can thus be read as “replace the channel’s contents with a tuple containing the base name and the file path”. The contents of the channel thus change from <code>[a.txt]</code> to <code>[a, a.txt]</code>. Passing the sample name or ID together with the sample data in this way is extremely useful in a workflow context and can greatly simplify downstream processes.</p>
<p>Before this will work, however, we have to change the process itself to make use of this new information contained in the <code>ch_input</code> channel.</p>
<ul>
<li>Change the process definition to the following:</li>
</ul>
<pre class="nextflow"><code>process CONVERT_TO_UPPER_CASE {
    publishDir "results/",
        mode: "copy"

    input:
    tuple val(sample), path(file)

    output:
    path("${sample}.upper.txt")

    script:
    """
    tr [a-z] [A-Z] &lt; ${file} &gt; ${sample}.upper.txt
    """
}</code></pre>
<p>Notice how the input now is aware that we’re passing a tuple as input, which allows us to use both the <code>file</code> variable (as before) and the new <code>sample</code> variable. All that’s left now is to change the input to our pipeline!</p>
<ul>
<li>Change the channel definition line from <code>.fromPath ( "a.txt" )</code> to <code>.fromPath ( ["a.txt", "b.txt"] )</code> and try running the pipeline. Make sure it works before you move on! Remember to use the <code>view()</code> operator if you want to inspect the channel contents in detail.</li>
</ul>
</section>
<section id="input-from-samplesheets" class="level3" data-number="2.6">
<h3 data-number="2.6" class="anchored" data-anchor-id="input-from-samplesheets"><span class="header-section-number">2.6</span> Input from samplesheets</h3>
<p>So far we’ve been specifying inputs using strings inside the workflow itself, but hard-coding inputs like this is not ideal. A better solution is to use samplesheets instead, <em>e.g.</em> comma- or tab-separated data files; this is standard for many pipelines, including <a href="https://nf-co.re/">nf-core</a>. Take, for example, the following CSV file:</p>
<pre class="no-highlight"><code>a,a.txt
b,b.txt</code></pre>
<p>This specifies the samples and their respective files on each row. Using such a file is much more portable, scalable and overall easier to use than simple hard-coding things in the workflow definition itself. We might also include an arbitrary number of additional metadata columns, useful for downstream processing and analyses. Using contents of files as input can be done using the <code>.splitCsv()</code> and <code>.map{}</code> operators, like so:</p>
<pre class="nextflow"><code>ch_input = Channel
    .fromPath ( "first_samplesheet.csv" )
    .splitCsv ( )
    .map      { row -&gt; tuple(row[0], file(row[1])) }</code></pre>
<p>The <code>.SplitCsv()</code> operator lets the channel know the input is a CSV file, while the <code>.map{}</code> operator makes the CSV content into a tuple from the first and second elements of each row.</p>
<ul>
<li><p>Change the input channel definition to the code above and create the <code>first_samplesheet.csv</code> file as shown above.</p></li>
<li><p>Add the <code>.view()</code> operator somewhere to show the contents of <code>ch_input</code>.</p></li>
<li><p>Execute the pipeline. Do you see what you expect? Remove the <code>.view()</code> operator before moving on.</p></li>
</ul>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>While we are still hard-coding the name of the samplesheet it is still much better to edit a samplesheet than having to edit the pipeline itself - there are also convenient ways to work around this using <em>parameters</em>, which we’ll talk more about later in this tutorial.</p>
</div>
</div>
<p>We can also specify a header in our samplesheet like so: <code>.splitCsv(header: true)</code>. This will allow us to reference the columns using their names instead of their index, <em>e.g.</em> <code>row.col1</code> instead of <code>row[0]</code>.</p>
<ul>
<li>Add an appropriate header to your samplesheet, make sure your workflow can read it and execute. Use <code>.view()</code> to see what’s going on, if needed.</li>
</ul>
</section>
<section id="adding-more-processes" class="level3" data-number="2.7">
<h3 data-number="2.7" class="anchored" data-anchor-id="adding-more-processes"><span class="header-section-number">2.7</span> Adding more processes</h3>
<p>It’s time to add more processes to our workflow! We have the two files <code>a.upper.txt</code> and <code>b.upper.txt</code>; the next part of the workflow is a step that concatenates the content of all these UPPERCASE files.</p>
<p>We already have a channel containing the two files we need: the output of the <code>CONVERT_TO_UPPER_CASE</code> process called <code>CONVERT_TO_UPPER_CASE.out</code>. We can use this output as input to a new process using the syntax: <code>CONVERT_TO_UPPER_CASE.out.collect()</code>. The <code>collect()</code> operator groups all the outputs in the channel into a single data object for the next process. This is a <em>many-to-one</em> type of operation: a stream with several files (<em>many</em>) is merged into a lone list of files (<em>one</em>). If <code>collect()</code> was not used, the next process would try to run a task for each file in the output channel.</p>
<p>Let’s put this in use by adding a new process to the workflow definition. We’ll call this process <code>CONCATENATE_FILES</code> and it will take the output from <code>CONVERT_TO_UPPER_CASE</code> as input, grouped using the <code>collect()</code> operator.</p>
<ul>
<li>Add a line to your workflow definition for this new process with the appropriate input - remember that you can use <code>.view()</code> to check channel contents; click below if you’re having trouble.</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>CONCATENATE_FILES( CONVERT_TO_UPPER_CASE.out.collect() )</code></pre>
</div>
</div>
</div>
<p>Now all we have to do is define the actual <code>CONCATENATE_FILES</code> process in the process definition section.</p>
<ul>
<li>Copy the following code as a new process into your workflow:</li>
</ul>
<pre class="nextflow"><code>process CONCATENATE_FILES {
    publishDir "results/",
        mode: "copy"

    input:
    path(files)

    output:
    path("*.txt")

    script:
    """
    cat ${files} &gt; concat.txt
    """
}</code></pre>
<ul>
<li><p>Run your workflow again and check the <code>results/</code> directory. At this point you should have three files there: <code>a.upper.txt</code>, <code>b.upper.txt</code> and <code>concat.txt</code>.</p></li>
<li><p>Inspect the contents of <code>concat.txt</code> - do you see everything as you expected?</p></li>
</ul>
<p>Note the use of <code>path(files)</code> as input. Although we pass a list of files as input, the list is considered a single object, and so the <code>files</code> variable references a list. Each file in that list can be individually accessed using an index e.g.&nbsp;<code>${files[0]}</code>, or as we do here, use the variable without an index to list all the input files.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Quick recap">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quick recap
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this section we’ve learnt:</p>
<ul>
<li>How to create, execute and extend workflows</li>
<li>How to explore the <code>work</code> directory and channel contents</li>
<li>How to couple sample names to sample data files</li>
<li>How to use samplesheets as input</li>
<li>How to collect multiple files as single inputs for processes</li>
</ul>
</div>
</div>
</section>
</section>
<section id="executing-workflows-1" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="executing-workflows-1"><span class="header-section-number">3</span> Executing workflows</h2>
<p>It’s time to start working with a more realistic workflow using the MRSA case study of this course! We’ve created a bare-bones version of this pipeline for you, but we’ll work our way through it as we go along and learn more about Nextflow’s features and functionality. The MRSA workflow looks like this:</p>
<pre class="nextflow"><code>workflow {

    // Workflow for generating count data for the MRSA case study

    // Get input files from a samplesheet
    ch_input = Channel
        .fromPath ( "samplesheet.csv" )
        .splitCsv ( header: true)

    // Define the workflow
    DOWNLOAD_FASTQ_FILES (
        ch_input
    )
    RUN_FASTQC (
        DOWNLOAD_FASTQ_FILES.out
    )
    RUN_MULTIQC (
        RUN_FASTQC.out[1].collect()
    )
    GET_GENOME_FASTA ()
    INDEX_GENOME (
        GET_GENOME_FASTA.out.fasta
    )
    ALIGN_TO_GENOME (
        DOWNLOAD_FASTQ_FILES.out,
        INDEX_GENOME.out.index
    )
    SORT_BAM (
        ALIGN_TO_GENOME.out.bam
    )
    GET_GENOME_GFF3 ()
    GENERATE_COUNTS_TABLE (
        SORT_BAM.out.bam.collect(),
        GET_GENOME_GFF3.out.gff
    )
}</code></pre>
<p>The workflow has one input channel named <code>ch_input</code>, which reads input from the <code>samplesheet.csv</code> file. We then define the processes to be executed by this workflow, nine in total. The first process (<code>DOWNLOAD_FASTQ_FILES</code>) takes the <code>ch_input</code> channel as input, while the rest of the processes takes the output of previous processes as input. Before we go into more detail regarding the ins-and-outs of this workflow, let’s start with some specifics of how workflows are executed and what you can get from them.</p>
<section id="reports-and-visualisations" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="reports-and-visualisations"><span class="header-section-number">3.1</span> Reports and visualisations</h3>
<p>Let’s start with running the workflow plus getting some reports and visualisation while we’re at it!</p>
<ul>
<li>Run the workflow using the following command: <code>nextflow run main_mrsa.nf   -with-report report.html -with-timeline timeline.html -with-dag dag.png</code>.</li>
</ul>
<p>After successful executing, you will find three more files in your current directory: <code>report.html</code>, <code>timeline.html</code> and <code>dag.png</code>. The first file contains a workflow report, which includes various information regarding execution such as runtime, resource usage and details about the different processes. The second file contains a timeline for how long each individual process took to execute, while the last contains a visualisation of the workflow itself.</p>
<p>Take a few minutes to browse these files for yourself. When running a workflow you can of course choose which of these additional files you want to include by picking which ones are important or interesting to you - or don’t include any!</p>
</section>
<section id="logs" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="logs"><span class="header-section-number">3.2</span> Logs</h3>
<p>Nextflow keeps a log of all the workflows that have been executed. Let’s check it out!</p>
<ul>
<li>Type <code>nextflow log</code> to get a list of all the executions.</li>
</ul>
<p>Here we get information about when the workflow was executed, how long it ran, its run name, whether it succeeded or not and what command was used to run it. You can also use <code>nextflow log &lt;run name&gt;</code> to show each task’s directory that was executed for that run. You can also supply the <code>-f</code> (or <code>-fields</code>) flag along with additional fields to show.</p>
<ul>
<li>Run <code>nextflow log &lt;run name&gt; -f hash,name,exit,status</code></li>
</ul>
<p>This shows us not only the beginning of each task’s working directory, but also its name, exit code and status (<em>i.e.</em> if it completed successfully or failed in some manner).</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Listing fields">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Listing fields
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you want to see a complete list of all the fields you might explore using the log, just type <code>nextflow log -l</code> or <code>nextflow log -list-fields</code>. This is highly useful for debugging when there’s some specific information about a run you’re particularly interested in!</p>
</div>
</div>
<p>We can also get even more detailed information about the latest run by looking into the <code>.nextflow.log</code> file!</p>
<ul>
<li>Look into the latest log by typing <code>less .nextflow.log</code>.</li>
</ul>
<p>You’ll be greeted by a wealth of debugging information, which may even seem a bit overkill at this point! This level of detail is, however, quite useful both as a history of what you’ve attempted and as an additional help when you run into errors! Also, it helps with advanced debugging - which we’ll get into later.</p>
</section>
<section id="re-running-workflows" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="re-running-workflows"><span class="header-section-number">3.3</span> Re-running workflows</h3>
<p>Something you often want to do in Nextflow (or any WfMS for that matter) is to re-run the workflow when you changed some input files or some of the code for its analyses, but you don’t want to re-run the entire workflow from start to finish. Let’s find out how this works in Nextflow!</p>
<ul>
<li>Run the same <code>nextflow run main_mrsa.nf</code> command again.</li>
</ul>
<p>You’ll notice that Nextflow actually re-ran the entire workflow from scratch, even though we didn’t change anything. This is the default behaviour of Nextflow.</p>
<ul>
<li>Let’s try that again: <code>nextflow run main_mrsa.nf -resume</code> instead.</li>
</ul>
<p>Now you can see that Nextflow didn’t actually re-run anything. The <code>-resume</code> flag instructed Nextflow to use the cached results from the previous run!</p>
<p>Nextflow automatically keeps track of not only changes to input files, but also changes to code, process definitions and scripts. You can thus change anything relating to your workflow and just re-run with the <code>-resume</code> flag and be sure that only processes relevant to your changes are executed again!</p>
<ul>
<li>Use <code>tree work/</code> to list the contents of the work directory.</li>
</ul>
<p>Because Nextflow keeps track of all the runs, we’ve now got two sets of files in the work directory. One set from the first run, and another from the second run. This can take up valuable space, so let’s clean that up.</p>
<ul>
<li>Use <code>nextflow clean -n -before &lt;run_name&gt;</code> to show which work directories will be cleaned up (use <code>nextflow log</code> to find the run name if you don’t remember it). Then delete those directories by changing <code>-n</code> (dry-run) to <code>-f</code> (force).</li>
</ul>
<p>Nextflow’s <code>clean</code> subcommand can be used to clean up failed tasks and unused processes. Here we used the <code>-before</code> flag, meaning that any runs before the specified run are removed; use <code>nextflow help clean</code> to see other options for cleaning. This is the preferred way to clean up the working directory.</p>
<ul>
<li>Remove the <code>results</code> directory and re-run the workflow again using the <code>-resume</code> flag.</li>
</ul>
<p>We removed all the results we used before, but we still managed to resume the workflow and use its cache - how come? Remember that Nextflow uses the <code>work</code> directory to run all of its tasks, while the <code>results</code> directory is just where we have chosen to publish our outputs. We can thus delete the <code>results</code> directory as often as we like (a necessity when output filenames are changed) and still get everything back without having to re-run anything. If we were to delete the <code>work</code> directory, however…</p>
<ul>
<li>Delete the <code>work</code> directory and re-run the workflow using the <code>-resume</code> flag.</li>
</ul>
<p>There is no longer any cache for Nextflow to use, so it re-runs from the start! This is good to keep in mind: you can always delete the output directories of your workflow, but if you mess with <code>work</code> you’ll lose, well… work!</p>
<div class="callout callout-style-default callout-note callout-titled" title="Quick recap">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quick recap
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this section we’ve learnt:</p>
<ul>
<li>How to get automatic reports and visualisations</li>
<li>How to check the Nextflow logs</li>
<li>How to re-run workflows</li>
<li>How to clean the Nextflow cache</li>
</ul>
</div>
</div>
</section>
</section>
<section id="working-with-processes" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="working-with-processes"><span class="header-section-number">4</span> Working with processes</h2>
<p>Now that we’ve gone through the specifics of executing workflows in a bit more detail, let’s go through working with processes. While there are numerous process directives that can be used, we’ll go through some of the more commonly used ones here.</p>
<section id="tags" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="tags"><span class="header-section-number">4.1</span> Tags</h3>
<p>Let’s look at the command line output we got during the workflow’s execution, which should look something like this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">N</span> E X T F L O W  ~  version 22.10.6</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Launching</span> <span class="kw">`</span><span class="ex">./main.nf</span><span class="kw">`</span> <span class="pp">[</span><span class="ss">friendly_bhaskara</span><span class="pp">]</span> <span class="at">-</span> revision: b4490b9201</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ex">executor</span> <span class="op">&gt;</span>  local <span class="er">(</span><span class="ex">17</span><span class="kw">)</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ex">[c9/e5f818]</span> process <span class="op">&gt;</span> DONWLOAD_FASTQ_FILES <span class="er">(</span><span class="ex">SRR935092</span><span class="kw">)</span> <span class="ex">[100%]</span> 3 of 3 ✔</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="ex">[d5/b5f24e]</span> process <span class="op">&gt;</span> RUN_FASTQC <span class="er">(</span><span class="ex">SRR935092</span><span class="kw">)</span>           <span class="ex">[100%]</span> 3 of 3 ✔</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="ex">[91/2cea54]</span> process <span class="op">&gt;</span> RUN_MULTIQC                      <span class="pp">[</span><span class="ss">100%</span><span class="pp">]</span> 1 of 1 ✔</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="ex">[e0/b4fd37]</span> process <span class="op">&gt;</span> GET_GENOME_FASTA                 <span class="pp">[</span><span class="ss">100%</span><span class="pp">]</span> 1 of 1 ✔</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="ex">[87/32ce10]</span> process <span class="op">&gt;</span> INDEX_GENOME                     <span class="pp">[</span><span class="ss">100%</span><span class="pp">]</span> 1 of 1 ✔</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="ex">[56/e9a460]</span> process <span class="op">&gt;</span> ALIGN_TO_GENOME <span class="er">(</span><span class="ex">SRR935092</span><span class="kw">)</span>      <span class="ex">[100%]</span> 3 of 3 ✔</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="ex">[ed/d8c223]</span> process <span class="op">&gt;</span> SORT_BAM <span class="er">(</span><span class="ex">SRR935092</span><span class="kw">)</span>             <span class="ex">[100%]</span> 3 of 3 ✔</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="ex">[e7/4a6bda]</span> process <span class="op">&gt;</span> GET_GENOME_GFF3                  <span class="pp">[</span><span class="ss">100%</span><span class="pp">]</span> 1 of 1 ✔</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="ex">[e9/84f093]</span> process <span class="op">&gt;</span> GENERATE_COUNTS_TABLE            <span class="pp">[</span><span class="ss">100%</span><span class="pp">]</span> 1 of 1 ✔</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Have you noticed that there are SRA IDs after some of the processes? Well, if you look at which processes show these SRA IDs you might see that it’s only those processes that are executed three times, <em>i.e.</em> once per SRA ID. This doesn’t happen automatically, however, and comes from something called <em>tags</em>. Let’s look at the <code>DONWLOAD_FASTQ_FILES</code> process:</p>
<pre class="nextflow"><code>process DONWLOAD_FASTQ_FILES {

    // Download a single-read FASTQ file from the SciLifeLab Figshare remote

    tag "${sra_id}"
    publishDir "results/data",
        mode: "copy"

    input:
    tuple val(sra_id), val(figshare_link)

    output:
    tuple val(sra_id), path("*.fastq.gz")

    script:
    """
    wget ${figshare_link} -O ${sra_id}.fastq.gz
    """
}</code></pre>
<p>You can see the <code>tag</code> directive at the very top of the process definition. Tags can be used to <em>e.g.</em> show information about the sample currently being analysed by the process. This is useful both during run-time (allowing you to see which sample is being processed) but also for debugging or finding problematic samples in case of errors or odd output. There is, naturally, no need to use tags for processes which are only run once.</p>
<ul>
<li>Comment out (prefix with <code>//</code>) the <code>tag</code> directive from the <code>DONWLOAD_FASTQ_FILES</code> process and run the workflow again. What do you see?</li>
</ul>
<p>Without the <code>tag</code> directive you should instead see the numbers 1 through 3, representing the input files (of which there are three). Nextflow still tells us that it’s working on one of the input files, but it’s generally much more useful to actually see the sample name or ID, rather than just a number.</p>
<ul>
<li>Uncomment the <code>tag</code> directive before you move on.</li>
</ul>
</section>
<section id="named-outputs" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="named-outputs"><span class="header-section-number">4.2</span> Named outputs</h3>
<p>Let’s move on to the next process! It looks like this:</p>
<pre class="nextflow"><code>process RUN_FASTQC {

    // Run FastQC on a FASTQ file.

    tag "${sample}"
    publishDir "results/",
        mode: "copy"

    input:
    tuple val(sample), path(fastq)

    output:
    path("*.html")
    path("*.zip")

    script:
    """
    fastqc ${fastq} -q
    """
}</code></pre>
<p>Here is a process with two output channels! One contains all the <code>.html</code> files, while the other contains all the <code>.zip</code> files. How is this handled in the workflow definition of downstream processes that use the outputs? The <code>RUN_MULTIQC</code> process uses this output, and its part in the workflow definition looks like this:</p>
<pre class="nextflow"><code>RUN_MULTIQC (
    RUN_FASTQC.out[1].collect()
)</code></pre>
<p>We already know about <code>.out</code> and <code>.collect()</code>, but we have something new here: the <code>RUN_MULTIQC</code> process is taking the second channel of the output from the <code>RUN_FASTQC</code> process - <code>[1]</code> is the index for the second channel, as Groovy is zero-based (the first channel is indexed by <code>[0]</code>).</p>
<p>This comes with some issues, however. What if we accidentally changed the order of the outputs in the rule, or added a new one? Using positions like this is easy to mess up, but there is a better solution: named outputs! This can be achieved by adding the <code>emit</code> option for some or all of the outputs, like so:</p>
<pre class="nextflow"><code>output:
path(*.txt), emit: text</code></pre>
<p>Instead of referring to the output by its position in an array as before we refer to the channel with a label we choose (<code>.out.text</code>) instead. This benefits us in that we can infer more information about channel contents called <code>text</code> rather than <code>[1]</code>, and it is also allows us to be less error-prone when rewriting parts of a workflow.</p>
<ul>
<li>Your turn! Add named outputs to the <code>RUN_FASTQC</code> process and make <code>RUN_MULTIQC</code> use those outputs. You’ll have to change both the output section of the <code>RUN_FASTQC</code> process, and the workflow definition section for <code>RUN_MULTIQC</code>. If you need help, see the hint below.</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// Workflow definition for RUN_MULTIQC
RUN_MULTIQC (
    RUN_FASTQC.out.zip.collect()
)

// Output section of RUN_FASTC
output:
path("*.html"), emit: html
path("*.zip"),  emit: zip</code></pre>
</div>
</div>
</div>
<p>Check if it works by executing the workflow.</p>
</section>
<section id="advanced-publishing" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="advanced-publishing"><span class="header-section-number">4.3</span> Advanced publishing</h3>
<p>So far we’ve only used the <code>publishDir</code> directive in a very simple way: specifying a directory and the <code>mode</code> to use when publishing (to copy the files rather than symbolically link them). There are more things you can do, however, especially for processes with more than one output. For example, we can publish outputs in separate directories, like so:</p>
<pre class="nextflow"><code>publishDir "results/tables",
    pattern: "*.tsv",
    mode: "copy"
publishDir "results/logs",
    pattern: "*.log",
    mode: "copy"</code></pre>
<p>In this example, <code>*.tsv</code> files are copied to the folder <code>results/tables/</code>, while <code>*.log</code> files are copied to the folder <code>results/logs</code>. The <code>publishDir</code> directive can be used multiple times in a single process, allowing one to separate output as above, or publish the same output to multiple folders.</p>
<ul>
<li>Edit the <code>RUN_FASTQC</code> process to place the HTML and compressed files in separate directories. Remove the <code>results</code> directory and re-run the workflow to check that it worked - click below if you’re having trouble.</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-12-contents" aria-controls="callout-12" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-12" class="callout-12-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>process RUN_FASTQC {

    (...)

    publishDir "results/fastqc/html",
        pattern: "*.html",
        mode: "copy"
    publishDir "results/fastqc/zip",
        pattern: "*.zip",
        mode: "copy"

    (...)
}
</code></pre>
</div>
</div>
</div>
<p>Note that an output and a <em>published</em> output are different things: something can be an output of a process without being published. In fact, the <code>RUN_FASTQC</code> process is a prime example of this! Think about the compressed output: this output is only used by the downstream process <code>RUN_MULTIQC</code> and is never meant to be viewed by a human or used by a human in some downstream task not part of the pipeline itself. We would thus like to keep the compressed files as an output, but not publish said output. How do we do this? Just remove the corresponding <code>publishDir</code> directive!</p>
<p>The MRSA workflow we’ve made here was refactored directly from its original version in the Snakemake tutorial of this course, which means that its output structure is not fully taking advantage of some of Nextflow’s functionality. The compressed output we’ve already talked about above is one example.</p>
<ul>
<li>See if you can find any other processes in the current implementation of the MRSA workflow that you could optimise like this!</li>
</ul>
<p>Think about whether all processes actually need to have published outputs. Make sure you test executing the workflow after you’ve made any changes; click below if you want a hint.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-13-contents" aria-controls="callout-13" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-13" class="callout-13-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The <code>GET_GENOME_FASTA</code> and <code>GET_GENOME_GFF3</code> both download reference files which are only needed by the workflow itself and does not need to be published, the same goes for the genome index generated by the <code>INDEX_GENOME</code> process.</p>
<p>One could argue that neither of the BAM files generated by the <code>ALIGN_TO_GENOME</code> and <code>SORT_BAM</code> processes are needed by the user if only the final counts table is of interest, but BAM files can also be useful for exploring the alignments in <em>e.g.</em> IGV. Both BAMs are, however, definitely not needed: only the sorted one should be published if one is interested in BAM files.</p>
</div>
</div>
</div>
</section>
<section id="debugging" class="level3" data-number="4.4">
<h3 data-number="4.4" class="anchored" data-anchor-id="debugging"><span class="header-section-number">4.4</span> Debugging</h3>
<p>It is, sadly, inevitable that we all make mistakes while coding - nobody’s perfect! Nextflow helps you quite a bit when this happens, not just with its logs but also with informative error messages. Let’s introduce an error and look at what we get:</p>
<ul>
<li>Change the final <code>output</code> line in the <code>RUN_MULTIQC</code> process to the following and re-run the workflow: <code>path("multiqc_general_stats.csv")</code> - notice the usage of <code>.csv</code> rather than <code>.txt</code> as before.</li>
</ul>
<p>We got an error! We get a number of things, actually, including (in order from the top) the name of the process that gave the error, the likely cause, the command that was executed, along with its exit status, output, error and the work directory that the task was run in. Let’s focus on the <code>Caused by:</code> part at the top, which should look something like this:</p>
<pre class="no-highlight"><code>Caused by:
  Missing output file(s) `multiqc_general_stats.csv` expected by process `RUN_MULTIQC`</code></pre>
<p>We can also see that the command’s exit status is <code>0</code>, which means that the command was successful; any exit status other than <code>0</code> means there was an error of some kind. We can thus infer that the command (1) worked, (2) failed to give us the output expected by Nextflow. Thankfully, Nextflow graciously prints the work directory for us so that we may check out what happened in more detail.</p>
<ul>
<li>Copy the working directory path, <code>cd</code> into it and list its contents using <code>ls</code>.</li>
</ul>
<p>You might already have spotted the error in the message above; the error we introduced here was that the expected output file has a <code>.csv</code> extension, rather than the correct <code>.txt</code>. Nextflow is expecting the <code>.csv</code> output, but the process <code>script</code> directive is (correctly) giving us the <code>.txt</code> file, which we can see inside the process’ work directory.</p>
<ul>
<li>Go back to the root directory, revert the error you introduced and re-run the workflow to make sure it works again.</li>
</ul>
<p>This might have seemed like a trivial error, but a lot of errors in Nextflow can be solved in the same manner, <em>i.e.</em> by just following the debugging output reported by Nextflow and inspecting the specific subdirectory in question.</p>
<div class="callout callout-style-default callout-note callout-titled" title="A note about Bash">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A note about Bash
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you are using Bash variables inside the <code>script</code> directive you have to be careful to prepend it with a backslash, <em>e.g.</em> <code>\${BASH_VARIABLE}</code>. This is because the dollar-sign is used by Nextflow, so you have to tell Nextflow explicitly when you’re using a Bash variable. This is a common source of errors when using Bash variables, so keeping it in mind can save you some debugging time!</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Quick recap">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quick recap
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this section we’ve learnt:</p>
<ul>
<li>How to use the <code>tag</code> directive</li>
<li>How to use named output with <code>emit</code></li>
<li>How to publish outputs into different directories</li>
<li>How to debug errors and mistakes</li>
</ul>
</div>
</div>
</section>
</section>
<section id="workflow-configuration" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="workflow-configuration"><span class="header-section-number">5</span> Workflow configuration</h2>
<p>We’ve so far been working with a relatively non-generalised workflow: it’s got hard-coded inputs, paths and genome references. This is perfectly fine for a project that is purely aimed at getting reproducible results (which is the full extent of what you want in a lot of cases), but it can be made a lot more generalisable. Let’s go through the MRSA workflow and see what can be improved!</p>
<section id="parameters" class="level3" data-number="5.1">
<h3 data-number="5.1" class="anchored" data-anchor-id="parameters"><span class="header-section-number">5.1</span> Parameters</h3>
<p>One of the things that allow generalisability of Nextflow workflows is <em>parameters</em>, which hold information and values that can be changed directly on the command-line at the time of execution. One use of parameters in our MRSA workflow is to remove the hard-coded <code>results</code> output directory, for example. Parameters can be written in the following form:</p>
<pre class="nextflow"><code>params {
    parameter_1 = "some/data/path"      // A string parameter
    parameter_2 = 42                    // A value parameter
    parameter_3 = ["a", "b", "c", "d"]  // A list parameter
}</code></pre>
<p>You would then refer to these parameters using <em>e.g.</em> <code>params.parameter_1</code> anywhere you need to in the workflow. Although parameters can be defined in <code>main_mrsa.nf</code>, it is preferable to define them in a separate <em>configuration file</em>. The default name of this file is <code>nextflow.config</code> and if such a file is present it will be used automatically by Nextflow (to supply a config file with another name use <code>nextflow -c &lt;path-to-config-file&gt; run main_mrsa.nf</code>)</p>
<ul>
<li><p>Create a configuration file and add a parameter for the <code>results</code> output directory.</p></li>
<li><p>Use your newly created parameter in the <code>publishDir</code> directory of a process Run your workflow to see if it worked; click below if you need help.</p></li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-16-contents" aria-controls="callout-16" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-16" class="callout-16-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// Configuration file
params {
    outdir = "results"
}

// A publishDir directive in a process
publishDir "${params.outdir}",
    mode: "copy"</code></pre>
</div>
</div>
</div>
</section>
<section id="command-line-parameters" class="level3" data-number="5.2">
<h3 data-number="5.2" class="anchored" data-anchor-id="command-line-parameters"><span class="header-section-number">5.2</span> Command line parameters</h3>
<p>Workflow parameters can be assigned on the command-line by executing workflows like so: <code>nextflow run main_mrsa.nf --parameter_name 'some_value'</code>. The workflow parameter <code>parameter_name</code> is prefixed by a double dash <code>--</code> to tell Nextflow this is a parameter to the workflow (a single dash is a parameter to Nextflow, <em>e.g.</em> <code>-resume</code>). The value is also quoted (this is important for parameters that take file paths as values).</p>
<ul>
<li>Run your workflow using the parameter you previously created, but pick something other than the default value!</li>
</ul>
<p>You should now have a new directory containing all the results! This is highly useful if you want to keep track of separate runs of a workflow with different software parameters, for example: <code>nextflow run main.nf --important_param 'value1' --resultsdir 'results-value1'</code>, or simply want to keep the results of separate versions of the same workflow. You can also change parameters by using the <code>-params-file</code> option or by using another configuration file (and using <code>-c</code>), rather than on the command line!</p>
</section>
<section id="configuring-inputs" class="level3" data-number="5.3">
<h3 data-number="5.3" class="anchored" data-anchor-id="configuring-inputs"><span class="header-section-number">5.3</span> Configuring inputs</h3>
<p>Remember the input for the MRSA workflow, the <code>ch_input</code> channel? This input (the <code>samplesheet.csv</code> file) is hard-coded inside the <code>main_mrsa.nf</code> file. This could also be made into a parameter!</p>
<ul>
<li>Change the definition of the <code>ch_input</code> channel to take the value of a new parameter of your choice, defined in the configuration file.</li>
</ul>
<p>You should now have a more generalised input to your workflow! Try to run it to make sure it works - look below if you need some help.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-17-contents" aria-controls="callout-17" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-17" class="callout-17-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// Channel definition
ch_input = Channel
    .fromPath ( params.input )
    .splitCsv ( header: true )

// Configuration file
input = "samplesheet.csv"</code></pre>
</div>
</div>
</div>
<p>By specifying inputs from sample sheets like this we can change inputs of a workflow execution by creating another sample sheet and specifying <em>e.g.</em>, <code>--input samplesheet-2.csv</code> on the command line. This is highly useful when you want to run a single sample <em>e.g.</em>, when testing a workflow, or when you want to keep track of all the different inputs you’ve used historically.</p>
</section>
<section id="other-configuration-scopes" class="level3" data-number="5.4">
<h3 data-number="5.4" class="anchored" data-anchor-id="other-configuration-scopes"><span class="header-section-number">5.4</span> Other configuration scopes</h3>
<p>There are lots of things that you might want to add to your configuration, not just parameters! The workflow <em>manifest</em>, for example, which might look like this:</p>
<pre class="nextflow"><code>manifest {
    name        = "My Workflow"
    description = "My awesome workflow, created by me"
    author      = "Me"
    mainScript  = "main.nf"
    version     = "1.0.0"
}</code></pre>
<ul>
<li>Go ahead and add a workflow manifest to your <code>nextflow.config</code> file!</li>
</ul>
<p>The manifest is useful when you’re publishing or sharing the workflow through <em>e.g.</em> GitHub or similar. There are many more such configuration <em>scopes</em> that you might want to use - read more about them <a href="https://www.nextflow.io/docs/latest/config.html#config-scopes">in the documentation</a>.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Quick recap">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quick recap
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this section we learnt:</p>
<ul>
<li>How to create parameters in a configuration file</li>
<li>How to specify parameters on the command line</li>
<li>How to add workflow manifest and other configuration scopes</li>
</ul>
</div>
</div>
</section>
</section>
<section id="optimising-the-mrsa-workflow" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="optimising-the-mrsa-workflow"><span class="header-section-number">6</span> Optimising the MRSA workflow</h2>
<p>We just added several parameters and configurations to our MRSA workflow, but we didn’t do anything about the reference genomes: those are still hard-coded. The current MRSA workflow is, in fact, not very well-optimised for Nextflow at all, being a refactor from the Snakemake tutorial of this course.</p>
<p>All of the processes are basically unchanged, excluding some minor alterations. For example, the <code>run_fastqc</code> rule in Snakemake used the <code>-o</code> flag to specify that the results should be in the current directory, followed by moving the output files to their respective output directory. The first part is not needed in Nextflow (as everything is run in its own subdirectory), and the second part is done by the <code>publishDir</code> directive. These are just minor alterations, though, but we can do much more if we fully utilise Nextflow’s features!</p>
<section id="remote-files" class="level3" data-number="6.1">
<h3 data-number="6.1" class="anchored" data-anchor-id="remote-files"><span class="header-section-number">6.1</span> Remote files</h3>
<p>One of these features is the ability to automatically download remote files, without needing to explicitly do so! The <code>path</code> input type can handle either file paths (like we’ve done so far) or a URI-supported protocol (such as <code>http://</code>, <code>s3://</code>, <code>ftp://</code>, <em>etc.</em>). This would be highly useful for <em>e.g.</em> the <code>GET_GENOME_FASTA</code> process - in fact, we don’t even need that process at all! All we need to do is to change the input to the <code>INDEX_GENOME</code> and <code>ALIGN_TO_GENOME</code> processes.</p>
<ul>
<li><p>Create a new input channel using the <code>fromPath()</code> channel factory and the absolute path (the FTP address) to the genome FASTA.</p></li>
<li><p>Make the <code>INDEX_GENOME</code> process use that input channel instead of the previously used output of the <code>GET_GENOME_FASTA</code> process.</p></li>
<li><p>Remove the <code>GET_GENOME_FASTA</code> process, as it is not needed anymore.</p></li>
</ul>
<p>Re-run the workflow to see if it worked. Check the code below for an example if you’re stuck:</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-19-contents" aria-controls="callout-19" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-19" class="callout-19-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// Channel creation
ch_genome_fasta = Channel.fromPath( "ftp://ftp.ensemblgenomes.org/pub/bacteria/release-37/fasta/bacteria_18_collection/staphylococcus_aureus_subsp_aureus_nctc_8325/dna/Staphylococcus_aureus_subsp_aureus_nctc_8325.ASM1342v1.dna_rm.toplevel.fa.gz" )

// Workflow definition
INDEX_GENOME (
    ch_genome_fasta
)</code></pre>
</div>
</div>
</div>
<p>We could also do this using parameters from our configfile, of course!</p>
<ul>
<li>Now change the input to the <code>GENERATE_COUNTS_TABLE</code> to use the remote GFF3 file and remove the <code>GET_GENOME_GFF3</code> in the same manner as above, but using a new parameter instead.</li>
</ul>
<p>Re-run the workflow again to make sure it worked; check below if you’re stuck.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-20-contents" aria-controls="callout-20" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-20" class="callout-20-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// [ nextflow.config ]
params {
    genome_gff3 = "ftp://ftp.ensemblgenomes.org/pub/bacteria/release-37/gff3/bacteria_18_collection/staphylococcus_aureus_subsp_aureus_nctc_8325/Staphylococcus_aureus_subsp_aureus_nctc_8325.ASM1342v1.37.gff3.gz"
}

// [ main.nf ]
// Channel creation
ch_genome_ggf3 = Channel.fromPath ( params.genome_gff3 )

// Workflow definition
GENERATE_COUNTS_TABLE (
    SORT_BAM.out.bam.collect(),
    ch_genome_ggf3
)</code></pre>
</div>
</div>
</div>
<p>If we want to get detailed we can also change the hard-coded “NCT8325” naming in <em>e.g.</em> the <code>INDEX_GENOME</code> process and put that in another parameter, or grab the <code>baseName()</code> from the channel and make a <code>[prefix, file]</code> tuple using the <code>map{}</code> operator like we did previously; check below if you’re curious of how this could be done.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-21-contents" aria-controls="callout-21" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-21" class="callout-21-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// Channel definition
ch_genome_fasta = Channel
    .fromPath( "ftp://ftp.ensemblgenomes.org/pub/bacteria/release-37/fasta/bacteria_18_collection/staphylococcus_aureus_subsp_aureus_nctc_8325/dna/Staphylococcus_aureus_subsp_aureus_nctc_8325.ASM1342v1.dna_rm.toplevel.fa.gz" )
    .map     { file -&gt; tuple(file.getBaseName(), file) }

// INDEX_GENOME process definition
process INDEX_GENOME {

    publishDir "results/bowtie2/",
        mode: "copy"

    input:
    tuple val(fasta_name), path(fasta)

    output:
    path("*.b2t"), emit: index

    script:
    """
    # Bowtie2 cannot use .gz, so unzip to a temporary file first
    gunzip -c ${fasta} &gt; tempfile
    bowtie2-build tempfile ${fasta_name}
    """
}</code></pre>
</div>
</div>
</div>
</section>
<section id="subworkflows" class="level3" data-number="6.2">
<h3 data-number="6.2" class="anchored" data-anchor-id="subworkflows"><span class="header-section-number">6.2</span> Subworkflows</h3>
<p>The DSL2 allows highly modular workflow design, where a workflow may contain multiple <em>subworkflows</em>. A subworkflow is just like a normal workflow, but it can be called inside other workflows, similar to a process. There is thus no special difference between a subworkflow and a workflow; the only difference is how you use them in practice. Let’s take a look at a toy example:</p>
<pre class="nextflow"><code>workflow {
    ch_input = Channel.fromPath ( params.input )
    SUBWORKFLOW (
        ch_input
    )
}

workflow SUBWORKFLOW {

    take:
    input_file

    main:
    ALIGN_READS( input_file )

    emit:
    bam = ALIGN_READS.out.bam
}</code></pre>
<p>Here we have an unnamed, main workflow like before, plus a named subworkflow. A workflow can have inputs specified by the <code>take</code> directive, which is the equivalent of process <code>input</code> for workflows. The <code>main</code> part is the workflow body, which contains how to run which processes in which order. The last part, <code>emit</code>, also works the same as for processes, in that we name the different outputs of the workflow so that we may use them in other workflows or processes. Nextflow will run the unnamed workflow by default, unless the <code>-entry</code> flag is specified, like so:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">nextflow</span> run main.nf <span class="at">-entry</span> SUBWORKFLOW</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This will run the workflow named <code>SUBWORKFLOW</code>, but nothing else. You can also store subworkflows in separate files, so that everything doesn’t have to be crammed into a single <code>main.nf</code> file. A subworkflow named <code>SUBWORKFLOW</code> contained in the file <code>subworkflow.nf</code> can be loaded into a <code>main.nf</code> file like so:</p>
<pre class="nextflow"><code>include { SUBWORKFLOW } from "./subworkflow.nf"</code></pre>
<p>If you have a complex workflow with several subworkflows you might thus store them in a separate directory, <em>e.g.</em> <code>subworkflows/</code>. This allows you to have fine-grained control over the general architecture of your Nextflow workflows, organising them in a manner that is easy to code and maintain. A <code>process</code> can also be treated in the same manner, and defined separately in another file.</p>
<ul>
<li>Now it’s your turn! Separate the <code>RUN_FASTQC</code> and <code>RUN_MULTIQC</code> processes out of the main workflow and into a subworkflow. Check below if you’re having trouble.</li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-22-contents" aria-controls="callout-22" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-22" class="callout-22-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// [ main.nf ]
// Include subworkflow
include { QUALITY_CONTROLS } from "./subworkflows/quality_controls.nf"

// Main workflow
QUALITY_CONTROLS (
    DOWNLOAD_FASTQ_FILES.out
)

// [ subworkflows/quality_controls.nf ]
// Quality controls subworkflow
workflow QUALITY_CONTROLS {

    take:
    fastq

    main:
    RUN_FASTQC (
        fastq
    )
    RUN_MULTIQC (
        RUN_FASTQC.out.zip.collect()
    )

    emit:
    html          = RUN_MULTIQC.out.html
    general_stats = RUN_MULTIQC.out.general_stats
}

// [ Include RUN_FASTQC and RUN_MULTIQC processes here ]</code></pre>
</div>
</div>
</div>
<p>If you want to challenge yourself, try to do the same with the <code>INDEX_GENOME</code>, <code>ALIGN_TO_GENOME</code> and <code>SORT_BAM</code> processes! Be careful of where you get your inputs and outputs; check below if you want one of the ways in which you can do this:</p>
<div class="callout callout-style-default callout-tip callout-titled" title="Click to show">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-23-contents" aria-controls="callout-23" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Click to show
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-23" class="callout-23-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<pre class="nextflow"><code>// [ main.nf ]
// Include subworkflow
include { ALIGNMENT } from "./subworkflows/alignment.nf"

// Main workflow
ALIGNMENT {
    ch_genome_fasta,
    DOWNLOAD_FASTQ_FILES.out
}

// [ subworkflows/alignment.nf ]
// Alignment subworkflow
workflow ALIGNMENT {

    take:
    fasta
    fastq

    main:
    INDEX_GENOME (
        fasta
    )
    ALIGN_TO_GENOME (
        fastq,
        INDEX_GENOME.out.index
    )
    SORT_BAM (
        ALIGN_TO_GENOME.out.bam
    )

    emit:
    bam = SORT_BAM.out.bam
}

// [ Include INDEX_GENOME, ALIGN_TO_GENOME and SORT_BAM processes here ]</code></pre>
</div>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Quick recap">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quick recap
</div>
</div>
<div class="callout-body-container callout-body">
<p>In this section we learnt:</p>
<ul>
<li>How to automatically download remote files</li>
<li>How to create and work with subworkflows</li>
</ul>
</div>
</div>
</section>
</section>
<section id="extra-material" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="extra-material"><span class="header-section-number">7</span> Extra material</h2>
<p>There are many more things you can do with Nextflow than covered here. If you are interested to learn more details about Nextflow, we will briefly show some of its advanced features in this section. But first, here are some links to additional resources on Nextflow:</p>
<ul>
<li><a href="http://nextflow-io.github.io/patterns/index.html">Nextflow patterns</a> that can help with common operations and concepts</li>
<li>The Nextflow <a href="https://www.nextflow.io/docs/latest/index.html">documentation</a></li>
<li>Nextflow training at <a href="https://seqera.io/training/">Seqera</a></li>
<li>A work-in-progress <a href="https://carpentries-incubator.github.io/workflows-nextflow/index.html">Nextflow Carpentry course</a></li>
<li>Community help from <a href="https://join.slack.com/t/nextflow/shared_invite/zt-11iwlxtw5-R6SNBpVksOJAx5sPOXNrZg">Nextflow’s Slack channel</a></li>
</ul>
<section id="using-containers-in-nextflow" class="level3" data-number="7.1">
<h3 data-number="7.1" class="anchored" data-anchor-id="using-containers-in-nextflow"><span class="header-section-number">7.1</span> Using containers in Nextflow</h3>
<p>Nextflow has built-in support for using both Docker and Apptainer containers (and others too), either with a single container for the workflow as a whole or separate containers for each individual process. The simplest way to do it is to have a single container for your entire workflow, in which case you simply run the workflow and specify the image you want to use, like so:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Run with docker</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ex">nextflow</span> run main.nf <span class="at">-with-docker</span> image-name</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Run with Apptainer</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="ex">nextflow</span> run main.nf <span class="at">-with-apptainer</span> image.sif</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you don’t want to supply this at every execution, you can also add it directly to your configuration file:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Docker configuration</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ex">process.container</span> = <span class="st">'image-name'</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ex">docker.enabled</span> = true</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Apptainer configuration</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="ex">process.container</span> = <span class="st">'path/to/image.sif'</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="ex">apptainer.enabled</span> = true</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If you instead would like to have each process use a different container you can use the <code>container</code> directive in your processes:</p>
<pre class="nextflow"><code>process PROCESS_01 {
    (...)
    container: 'image_01'
    (...)
}

process PROCESS_02 {
    (...)
    container: 'image_02'
    (...)
}</code></pre>
<p>Regardless of which solution you go for, Nextflow will execute all the processes inside the specified container. In practice, this means that Nextflow will automatically wrap your processes and run them by executing the Docker or Apptainer command with the image you have provided.</p>
</section>
<section id="using-conda-in-nextflow" class="level3" data-number="7.2">
<h3 data-number="7.2" class="anchored" data-anchor-id="using-conda-in-nextflow"><span class="header-section-number">7.2</span> Using Conda in Nextflow</h3>
<p>While you can execute Nextflow inside Conda environments just like you would any other type of software, you can also use Conda with Nextflow in the same way as for Docker and Apptainer above. You can either supply an <code>environment.yml</code> file, the path to an existing environment or the packages and their versions directly in the <code>conda</code> directive, like so:</p>
<pre class="nextflow"><code>process PROCESS_01 {
    (...)
    conda: 'mrsa-environment.yml'
    (...)
}
process PROCESS_02 {
    (...)
    conda: 'path/to/mrsa-env'
    (...)
}
process PROCESS_03 {
    (...)
    conda: 'bioconda::bwa=0.7.17 bioconda::samtools=1.13'
    (...)
}</code></pre>
<p>You can use either of the methods described above with your configuration file as well, here exemplified using an <code>environment.yml</code> file:</p>
<pre class="nextflow"><code>process.conda = 'mrsa-environment.yml'</code></pre>
</section>
<section id="running-nextflow-on-uppmax" class="level3" data-number="7.3">
<h3 data-number="7.3" class="anchored" data-anchor-id="running-nextflow-on-uppmax"><span class="header-section-number">7.3</span> Running Nextflow on Uppmax</h3>
<p>A lot of researchers in Sweden are using the Uppmax computer cluster in Uppsala, which is easily handled by Nextflow. What you need to do is to add the following <em>profile</em> to your <code>nextflow.config</code> file:</p>
<pre><code>profiles {
    // Uppmax general profile
    uppmax {
        params {
            account        = null
        }
        process {
            executor       = 'slurm'
            clusterOptions = "-A '${params.account}'"
            memory         = { 6.GB * task.attempt }
            cpus           = { 1 * task.attempt }
            time           = { 10.h * task.attempt }
            scratch        = '$SNIC_TMP'
            errorStrategy  = 'retry'
            maxRetries     = 1
        }
    }
}</code></pre>
<p>This will add a profile to your workflow, which you can access by running the workflow with <code>-profile uppmax</code>. You will also have to supply an extra parameter <code>account</code> which corresponds to your SNIC project account, but the rest you can leave as-is, unless you want to tinker with <em>e.g.</em> compute resource specifications. That’s all you need! Nextflow will take care of communications with SLURM (the system used by Uppmax, specified by the <code>executor</code> line) and will send off jobs to the cluster for you, and everything will look exactly the same way as if you were executing the pipeline locally.</p>
<p>The <code>memory</code>, <code>cpus</code> and <code>time</code> lines define the various resources Nextflow will use as well as how much to automatically increase them by if re-trying failed tasks; this, in turn, is specified by the <code>errorStrategy</code> and <code>maxRetries</code> variables. The <code>scratch</code> variable defines where each node’s local storage is situated, which gives Nextflow the most optimal access to the Uppmax file system for temporary files.</p>
</section>
<section id="advanced-channel-creation" class="level3" data-number="7.4">
<h3 data-number="7.4" class="anchored" data-anchor-id="advanced-channel-creation"><span class="header-section-number">7.4</span> Advanced channel creation</h3>
<p>The input data shown in the MRSA example workflow is not that complex, but Nextflow channels can do much more than that. A common scenario in high-throughput sequencing is that you have pairs of reads for each sample. Nextflow has a special, built-in way to create channels for this data type: the <code>fromFilePairs</code> channel factory:</p>
<pre class="nextflow"><code>ch_raw_reads = Channel
    .fromFilePairs ( "data/*_R{1,2}.fastq.gz" )</code></pre>
<p>This will create a channel containing all the reads in the <code>data/</code> directory in the format <code>&lt;sample&gt;_R1.fastq.gz</code> and <code>&lt;sample&gt;_R2.fastq.gz</code> and will pair them together into a nested tuple looking like this:</p>
<pre class="nextflow"><code>[sample, [data/sample_R1.fastq.gz, data/sample_R2.fastq.gz]]</code></pre>
<p>The first element of the tuple (<code>[0]</code>) thus contains the value <code>sample</code>, while the second element (<code>[1]</code>) contains another tuple with paths to both read files. This nested tuple can be passed into processes for <em>e.g.</em> read alignment, and it makes the entire procedure of going from read pairs (<em>i.e.</em> two separate files, one sample) into a single alignment file (one file, one sample) very simple. For more methods of reading in data see the Nextflow documentation on <a href="https://www.nextflow.io/docs/latest/channel.html#channel-factory">Channel Factories</a>.</p>
<p>We can also do quite advanced things to manipulate data in channels, such as this:</p>
<pre class="nextflow"><code>samples_and_treatments = Channel
    .fromPath ( params.metadata )
    .splitCsv ( sep: "\t", header: true )
    .map      { row -&gt; tuple("${row.sample_id}", "${row.treatment}") }
    .filter   { id, treatment -&gt; treatment != "DMSO" }
    .unique   ( )</code></pre>
<p>That’s a bit of a handful! But what does it do? The first line specifies that we want to read some data from a file specified by the <code>metadata</code> parameter, and the second line actually reads that data using tab as delimiter, including a header. The <code>map</code> operator takes each entire row and subsets it to only two columns: the <code>sample_id</code> and <code>treatment</code> columns (discarding the other columns). This subset is stored as a tuple. The <code>filter</code> operator is then used to remove any tuples where the second entry (<code>treatment</code>) is not equal to the string <code>"DMSO"</code> (<em>i.e.</em> untreated cells, in this example). Finally, we only keep unique tuple values. Let’s say that this is the metadata we’re reading:</p>
<pre class="no-highlight"><code>sample        dose    group     treatment
sample_1      0.1     control   DMSO
sample_1      1.0     control   DMSO
sample_1      2.0     control   DMSO
sample_2      0.1     case      vorinostat
sample_2      1.0     case      vorinostat
sample_2      2.0     case      vorinostat
sample_3      0.1     case      fulvestrant
sample_3      1.0     case      fulvestrant
sample_3      2.0     case      fulvestrant</code></pre>
<p>Given the channel creation strategy above, we would get the following result:</p>
<pre class="no-highlight"><code>[sample_2, vorinostat]
[sample_3, fulvestrant]</code></pre>
<p>In this way, you can perform complex operations on input files or input metadata and send the resulting content to your downstream processes in a simple way. Composing data manipulations in Nextflow like this can be half the fun of writing the workflow. Check out Nextflow’s documentation on <a href="https://www.nextflow.io/docs/latest/operator.html">Channel operators</a> to see the full list of channel operations at your disposal.</p>
</section>
<section id="using-groovy-in-processes" class="level3" data-number="7.5">
<h3 data-number="7.5" class="anchored" data-anchor-id="using-groovy-in-processes"><span class="header-section-number">7.5</span> Using Groovy in processes</h3>
<p>You don’t have to use bash or external scripts inside your processes all the time unless you want to: Nextflow is based on Groovy, which allows you to use both Groovy and Bash in the same process. For example, have a look at this:</p>
<pre class="nextflow"><code>process index_fasta {
    tag "${fasta_name}"

    input:
    tuple val(fasta), path(fasta_file)

    output:
    path("${fasta_name}.idx"), emit: fasta

    script:
    fasta_name = fasta.substring(0, fasta.lastIndexOf("."))
    """
    index --ref ${fasta_file},${fasta_name}
    """
}</code></pre>
<p>Here we have some command <code>index</code> that, for whatever reason, requires both the path to a FASTA file and the name of that file <em>without</em> the <code>.fasta</code> extension. We can use Groovy in the <code>script</code> directive together with normal Bash, mixing and matching as we like. The first line of the <code>script</code> directive gets the name of the FASTA file without the extension by removing anything after the dot, while the second calls the <code>index</code> command like normal using bash.</p>
</section>
<section id="the-nf-core-pipeline-collection" class="level3" data-number="7.6">
<h3 data-number="7.6" class="anchored" data-anchor-id="the-nf-core-pipeline-collection"><span class="header-section-number">7.6</span> The nf-core pipeline collection</h3>
<p>You may have heard of the <a href="https://nf-co.re/">nf-core</a> pipeline collection previously, which is a large, collaborative bioinformatics community dedicated to building, developing and maintaining Nextflow workflows. In fact, if you have sequenced data at <em>e.g.</em> the National Genomics Infrastructure (<a href="https://ngisweden.scilifelab.se/">NGI</a>), you can be sure that the data processing has been run using one of the nf-core pipelines! While the community only started in 2018 (with a <a href="https://www.nature.com/articles/s41587-020-0439-x">Nature Biotechnology</a> paper in 2020), it already has over 30 production-ready pipelines with everything from genomics, transcriptomics, proteomics and metagenomics - and more being developed all the time.</p>
<p>The nf-core pipelines all work in the same way, in that they have the same exact base for inputs, parameters and arguments, making them all highly similar to run. Since you’ve already learnt the basics of Nextflow in this course, you should now be able to also run the nf-core pipelines! It might be that you have a data type that you can analyse using one of the pipelines in nf-core, meaning you don’t need to do anything other than find out what parameters you should run it with.</p>
<p>Each pipeline comes with extensive documentation, test datasets that you can use to practice on, can be run on both HPCs like Uppmax, cloud services like AWS or locally on your own computer. All pipelines support both Conda and Docker/Apptainer, and you can additionally run specific versions of the pipelines, allowing for full reproducibility of your analyses. If you want to check nf-core out, simply head over to their <a href="https://nf-co.re/pipelines">list of pipelines</a> and see what’s available! Who knows, you might even write your own nf-core pipeline in the future?</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>2024 <a href="https://nbis.se">NBIS</a> | <a href="https://choosealicense.com/licenses/gpl-3.0/">GPL-3 License</a></p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Published with <a href="https://quarto.org/">Quarto</a> v1.4.549
</p>
</div>
  </div>
</footer>




<script src="../site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>